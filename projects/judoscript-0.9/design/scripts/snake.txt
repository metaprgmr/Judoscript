==============================================================================
Class org.python.util.jython
==============================================================================

  main(args) {

    PySystemState.initialize(system props, cmdline props, cmdline args);

    // Now create an interpreter
    InteractiveConsole interp = new a class of property of "python.console",
                                default: new InteractiveConsole();

    PyModule mod = imp.addModule("__main__");
    interp.setLocals(mod.__dict__);

    // import site ... don't care at the moment.

    if command specified on cmdline {
      interp.exec(the command);
    }

    Py.getSystemState().path.insert(the path or "");

    if a jar is on cmdline {
      runJar(filename);
    elif file is on cmdline {
      interp.execfile(filename);
    elif '-' is on cmdline {
      interp.execfile(System.in, "<stdin>");
    }

    if is interactive {
      interp.interact(null);
    }
    interp.cleanup();

  } // end of main().


  runJar(String filename) {
    get __run__.py in the zip file (must be there);

    PyStringMap locals = new PyStringMap();
    locals.__setitem__("__name__", new PyString(filename));
    locals.__setitem__("zipfile", Py.java2py(zip));

    PyCode code = Py.compile(InputStream of __run__.py, "__run__", "exec");
    Py.runCode(code, locals, locals);
  }


==============================================================================
Class org.python.util.InteractiveConsole extends InteractiveInterpreter
==============================================================================
  public String filename;

  public InteractiveConsole(PyObject locals, String filename) {
    super(locals);
    this.filename = filename;
  }

  interact(String banner) {
    exec("2"); // Dummy exec to speed up response on 1st command

    boolean more = false;
    do {
      PyObject prompt = more ? systemState.ps2 : systemState.ps1;
      String line = raw_input(prompt);
      more = push(line);
    } until EOF;
  }

  /**
   * Push a line to the interpreter.
   *
   * The line should not have a trailing newline; it may have internal
   * newlines.  The line is appended to a buffer and the interpreter's
   * runsource() method is called with the concatenated contents of the
   * buffer as source.  If this indicates that the command was executed
   * or invalid, the buffer is reset; otherwise, the command is
   * incomplete, and the buffer is left as it was after the line was
   * appended.  The return value is 1 if more input is required, 0 if
   * the line was dealt with in some way (same as runsource()).
   **/
  boolean push(String line) {
    if (buffer.length() > 0)
      buffer.append("\n");
    buffer.append(line);
    boolean more = runsource(buffer.toString(), filename);
    if (!more)
      resetbuffer();
    return more;
  }

  /**
   * Write a prompt and read a line.
   *
   * The returned line does not include the trailing newline.  When the
   * user enters the EOF key sequence, EOFError is raised.
   *
   * The base implementation uses the built-in function raw_input(); a
   * subclass may replace this with a different implementation.
   **/
  public String raw_input(PyObject prompt) {
    return __builtin__.raw_input(prompt);
  }



==============================================================================
Class org.python.util.InteractiveInterpreter extends PythonInterpreter {
==============================================================================
  InteractiveInterpreter(PyObject locals) {
    super(locals);
    cflags = new CompilerFlags();
  }

  /**
   * Compile and run some source in the interpreter.
   *
   * Arguments are as for compile_command().
   *
   * One several things can happen:
   *
   * 1) The input is incorrect; compile_command() raised an exception
   * (SyntaxError or OverflowError).  A syntax traceback will be printed
   * by calling the showsyntaxerror() method.
   *
   * 2) The input is incomplete, and more input is required;
   * compile_command() returned None.  Nothing happens.
   *
   * 3) The input is complete; compile_command() returned a code object.
   * The code is executed by calling self.runcode() (which also handles
   * run-time exceptions, except for SystemExit).
   *
   * The return value is 1 in case 2, 0 in the other cases (unless an
   * exception is raised).  The return value can be used to decide
   * whether to use sys.ps1 or sys.ps2 to prompt the next line.
   **/

  boolean runsource(String source, String filename) {
    return runsource(source, filename, "single");
  }

  boolean runsource(String source, String filename, String symbol) {
    PyObject code = org.python.modules.codeop.compile_command_flags(
      source, filename, symbol,cflags);
    if (code == Py.None)
      return true;
    runcode(code);
    return false;
  }

  /**
   * execute a code object.
   *
   * When an exception occurs, self.showtraceback() is called to display
   * a traceback.  All exceptions are caught except SystemExit, which is
   * reraised.
   *
   * A note about KeyboardInterrupt: this exception may occur elsewhere
   * in this code, and may not always be caught.  The caller should be
   * prepared to deal with it.
   **/
  void runcode(PyObject code) { exec(code); }

  /** Pause the current code, sneak an exception raiser into
   * sys.trace_func, and then continue the code hoping that JPython will
   * get control to do the break;
   **/
  public void interrupt(ThreadState ts) {
    TraceFunction breaker = new BreakTraceFunction(); // an in-file class
    TraceFunction oldTrace = ts.systemState.tracefunc;
    ts.systemState.tracefunc = breaker;
    if (ts.frame != null)
      ts.frame.tracefunc = breaker;
    ts.systemState.tracefunc = oldTrace;
    //ts.thread.join();
  }
}

==============================================================================
Class org.python.util.PythonInterpreter {
==============================================================================

  PyModule module;
  protected PySystemState systemState;
  PyObject locals;

  protected CompilerFlags cflags = null;

  /**
   * Initialize the jython runtime. This method should only be
   * called once, and should be call before any other python objects
   * are created (included a PythonInterpreter).
   *
   * @param preProperties   A set of properties. Typically
   *                        System.getProperties() is used.
   * @param postProperties  An other set of properties. Values like
   *                        python.home, python.path and all other
   *                        values from the registry files can be
   *                        added to this property set. PostProperties
   *                        will override system properties and
   *                        registry properties.
   * @param argv            Command line argument. These values will
   *                        assigned to sys.argv.
   */
  static void initialize(Properties preProperties,
                         Properties postProperties,
                         String[] argv) {
    PySystemState.initialize(preProperties, postProperties, argv);
  }

  PythonInterpreter(PyObject dict, PySystemState systemState) {
    PySystemState.initialize();
    if (dict == null)
        dict = new PyStringMap();
    if (systemState == null) {
        systemState = Py.getSystemState();
        if (systemState == null)
            systemState = new PySystemState();
    }
    module = new PyModule("main", dict);
    this.systemState = systemState;
    locals = module.__dict__;
    setState();
  }

  protected void setState() {
    Py.setSystemState(systemState);
  }

  void setOut(PyObject outStream) {
    systemState.stdout = outStream;
  }

  void setOut(Writer outStream) {
    setOut(new PyFile(outStream));
  }

  void setOut(OutputStream outStream) {
    setOut(new PyFile(outStream));
  }

  void setErr(PyObject outStream) {
    systemState.stderr = outStream;
  }

  void setErr(Writer outStream) {
    setErr(new PyFile(outStream));
  }

  void setErr(OutputStream outStream) {
    setErr(new PyFile(outStream));
  }

  PyObject eval(String s) {
    setState();
    return __builtin__.eval(new PyString(s), locals);
  }

  void exec(String s) {
    setState();
    Py.exec(Py.compile_flags(s, "<string>", "exec",cflags),
            locals, locals);
  }

  void exec(PyObject code) {
    setState();
    Py.exec(code, locals, locals);
  }

  void execfile(String s) {
    setState();
    __builtin__.execfile_flags(s, locals, locals, cflags);
  }

  void execfile(InputStream s) {
    execfile(s, "<iostream>");
  }

  void execfile(InputStream s, String name) {
    setState();
    Py.runCode(Py.compile_flags(s, name, "exec",cflags), locals, locals);
  }

  PyObject getLocals() {
    return locals;
  }

  void setLocals(PyObject d) {
    locals = d;
  }

  void set(String name, Object value) {
    locals.__setitem__(name.intern(), Py.java2py(value));
  }

  void set(String name, PyObject value) {
    locals.__setitem__(name.intern(), value);
  }

  PyObject get(String name) {
    return locals.__finditem__(name.intern());
  }

  Object get(String name, Class javaclass) {
    return Py.tojava(locals.__finditem__(name.intern()), javaclass);
  }

  void cleanup() {
    systemState.callExitFunc();
  }


==============================================================================
Class org.python.util.PythonObjectInputStream   -- other
Class org.python.util.ReadlineConsole           -- other
==============================================================================


